---
creation date: 2023-09-22 15:58
---
 [[2023-09-22-星期五]]  #🌲长青 [[1.1-ke-cheng-jian-jie#1.1 课程内容简介]]

这篇文章记录了我对于 MIT 6. S081 Operating System Engineering 课程的学习理解与心得，也有做笔记的成分在，记录一些重要的概念。每个章节对应的实验也会放在最后。
## 操作系统的目标
1. 第一个就是抽象硬件。通常来说，你会买一个计算机，里面包含了 CPU，内存，但是这是一种非常低层级的资源。幸好我们有一些应用程序实现了高层级的接口和抽象，例如进程，文件系统。这些高层级的接口和抽象（Abstraction）方便了应用的开发，也提供了更好的移植性。
2. 操作系统的另一个重要的任务是：在多个应用程序之间共用硬件资源。你可以在一个操作系统同时运行文本编辑器，程序编译器，多个数据库等等。操作系统能非常神奇的在不相互干扰的前提下，同时运行这些程序。这里通常被称为 multiplex。
3. 因为在操作系统中可能同时运行很多程序，即使程序出现了故障，多个程序之间互不干扰就变得非常重要。所以这里需要隔离性（Isolation），不同的活动之间不能相互干扰。
4. 但是另一方面，不同的活动之间有时又想要相互影响，比如说数据交互，协同完成任务等。举个例子，我通过文本编辑器创建了一个文件，并且我希望我的编译器能读取文件，我绝对想要数据能共享。所以，我们希望能在需要的时候实现共享（Sharing）。
5. 但是在很多场景下，用户并不想要共享，比如你登录到了一个公共的计算机，例如 Athena，你不会想要其他人来读取你的文件。所以在共享的同时，我们也希望在没有必要的时候不共享。这里我们称为 Security 或者 Permission System 或者是 Access Control System。
6. 另一个人们认为操作系统应该具有的价值是：如果你在硬件上花费了大量的金钱，你会期望你的应用程序拥有硬件应该提供的完整性能，但是很多时候你只负责应用程序编程，你会期望操作系统也必须保证自身提供的服务不会阻止应用程序获得高性能。所以操作系统需要至少不阻止应用程序获得高性能，甚至需要帮助应用程序获得高性能（Performance）。
7. 最后，对于大部分操作系统，必须要支持大量不同类型的应用程序，或许这是一个笔记本，正在运行文本编辑器，正在运行游戏，或许你的操作系统需要支持数据库服务器和云计算。通常来说，设计并构造一个操作系统代价是非常大的，所以人们总是希望在相同的操作系统上，例如 Linux，运行大量的任务。我认为大部分人都已经跑过 Linux，并使用了我刚刚描述的所有的场景。所以，同一个操作系统需要能够支持大量不同的用户场景。

## 操作系统结构

![](https://rcore-os.cn/rCore-Tutorial-Book-v3/_images/computer-hw-sw.png)

当我想到这里的组织结构时，我首先会想到用一个矩形表示一个计算机。
- 最低一层：硬件资源包括了 CPU，内存，磁盘，网卡。
- 最上层：我们会运行各种各样的应用程序，或许有一个文本编辑器（VI），或许有一个 C 编译器（CC）。这里程序都运行在同一个空间中，这个空间通常会被称为用户空间（Userspace）。

区别于用户空间程序，有一个特殊的程序总是会在运行，它称为内核 Kernel。Kernel 是计算机资源的守护者。当你打开计算机时，Kernel 总是第一个被启动。Kernel 程序只有一个，它维护数据来管理每一个用户空间进程。Kernel 同时还维护了大量的数据结构来帮助它管理各种各样的硬件资源，以供用户空间的程序使用。Kernel 同时还有大量内置的服务，例如，Kernel 通常会有文件系统实现类似文件名，文件内容，目录的东西，并理解如何将文件存储在磁盘中。所以用户空间的程序会与 Kernel 中的文件系统交互，文件系统再与磁盘交互。

在这门课程中，我们主要关注点在 Kernel、连接 Kernal 和用户空间程序的接口、Kernel 内软件的架构。所以，我们会关心 Kernel 中的服务，其中一个服务是文件系统，另一个就是进程管理系统。每一个用户空间程序都被称为一个进程，它们有自己的内存和共享的 CPU 时间。同时，Kernel 会管理内存的分配。不同的进程需要不同数量的内存，Kernel 会复用内存、划分内存，并为所有的进程分配内存。

## 操作系统接口
操作系统的任务是在多个程序之间<span style="background:#fff88f">共享一台计算机</span>，并<span style="background:#fff88f">提供比硬件本身支持的更有用的服务。</span>
操作系统通过接口向用户程序提供服务。
接口包括用户接口和程序接口（一组<span style="background:rgba(240, 167, 216, 0.55)">系统调用</span>），程序接口即用户程序看到的接口。
![img](12%20-%20OS🐮/6.S081-All-in-one/tranlate_books/book-riscv-rev1/images/c1/p1.png)
xv6采用传统的内核形式（内核 (Kernel)是一个特殊的<font color="#ff0000">程序</font>，为正在运行的程序提供服务）。每个正在运行的程序，称为进程，都有包含<span style="background:#fff88f">指令、数据和堆栈的内存</span>。
当一个进程需要调用一个内核服务时，它会调用一个系统调用。<u>系统调用进入内核；内核执行服务并返回。</u>因此，一个进程在用户空间和内核空间之间交替执行。
> 学生提问：系统调用跳到内核与标准的函数调用跳到另一个函数相比，区别是什么？
>
> Robert 教授：Kernel 的代码总是有特殊的权限。当机器启动 Kernel 时，Kernel 会有特殊的权限能直接访问各种各样的硬件，例如磁盘。而普通的用户程序是没有办法直接访问这些硬件的。所以，当你执行一个普通的函数调用时，你所调用的函数并没有对于硬件的特殊权限。然而，如果你触发系统调用到内核中，内核中的具体实现会具有这些特殊的权限，这样就能修改敏感的和被保护的硬件资源，比如访问硬件磁盘。我们之后会介绍更多有关的细节。
## 进程和内存
- Xv6进程由用户空间内存 (指令、数据和堆栈)和对内核私有的每个进程状态组成。
- 指令实现了程序的运算，数据是计算所依赖的变量，堆栈组织程序的过程调用。
- 分时进程: 它透明地在等待执行的进程集合中切换可用的 CPU。当一个进程没有执行时，xv6保存它的 CPU 寄存器，并在下一次运行该进程时恢复它们。内核利用进程 id 或 PID 标识每个进程。
### 子进程
一个进程可以使用 fork 系统调用创建一个新的进程，其<span style="background:#fff88f">内存内容</span><span style="background:#fff88f">与调用进程（称为父进程）完全相同</span>，称其为子进程。二者在运行中拥有<span style="background:#fff88f">不同的内存空间和寄存器</span>：在一个进程中改变变量不会影响到另一个进程。
Fork 在父子进程中都返回值。在父进程中，fork 返回子类的 PID；在子进程中，fork 返回零。
> 学生提问：当我们说子进程从父进程拷贝了所有的内存，这里具体指的是什么呢？是不是说子进程需要重新定义变量之类的？
> 
> Robert教授：在编译之后，你的C程序就是一些在内存中的指令，这些指令存在于内存中。所以这些指令可以被拷贝，因为它们就是内存中的字节，它们可以被拷贝到别处。通过一些有关虚拟内存的技巧，可以使得子进程的内存与父进程的内存一样，这里实际就是将父进程的内存镜像拷贝给子进程，并在子进程中执行。

实际上，当我们在看C程序时，你应该认为它们就是一些机器指令，这些机器指令就是内存中的数据，所以可以被拷贝。
## IO 和文件描述符
文件描述符是一个小整数 (small integer)，表示进程可以读取或写入的由内核管理的对象。
一个<span style="background:#fff88f">强大的抽象</span>：
- 将文件、管道和设备之间的差异抽象出来，使它们看起来都像字节流。它们隐藏了它们所连接的细节：写入文件描述符1的进程可能写入文件、设备（如控制台）或管道。

进程可以通过打开一个文件、目录、设备，或创建一个管道，或复制一个已存在的描述符来获得一个文件描述符。
我们通常<span style="background:#fff88f">将文件描述符所指的对象称为“文件”</span>；
在内部，xv6内核使用文件描述符作为每个进程表的索引，这样每个进程都有一个从零开始的文件描述符的私有空间。
进程从文件描述符0读取（标准输入），将输出写入文件描述符1（标准输出），并将错误消息写入文件描述符2（标准错误）。
## 管道
管道是作为==一对文件描述符==公开给进程的<font color="#ff0000">小型内核缓冲区</font>，一个用于读取，一个用于写入。将数据写入管道的一端使得这些数据可以从管道的另一端读取。管道**为进程**提供了一种**通信方式**。
管道相比临时文件至少有四个优势
- 首先，管道会自动清理自己；在文件重定向时，shell 使用完 `/tmp/xyz` 后必须小心删除

- 其次，管道可以任意传递长的数据流，而文件重定向需要磁盘上足够的空闲空间来存储所有的数据。

- 第三，管道允许并行执行管道阶段，而文件方法要求第一个程序在第二个程序启动之前完成。

- 第四，如果实现进程间通讯，管道的**阻塞**式读写比文件的非阻塞语义更高效。
## 文件系统
文件系统的作用是管理文件内容并找出文件具体在磁盘中的哪个位置。
Xv6文件系统提供数据文件（包含未解释的字节数组）和目录（包含对数据文件和其他目录的命名引用）。这些目录形成一个树，从一个叫做根的特殊目录开始。像 `/a/b/c` 这样的路径是指在根目录 `/` 下名为 `a` 的目录中名为 `b` 的目录中名为 `c` 的文件或目录。
一个文件的名字和文件本身是不同的; 同一个<span style="background:#fff88f">底层文件（叫做 inode，</span><span style="background:#fff88f">索引结点</span>）可以有<span style="background:#fff88f">多个名字（叫做 link，链接</span>）。每个链接都由目录中的一个条目组成; 该条目包含一个文件名和一个 inode 引用。Inode 保存有关文件的元数据（用于解释或帮助理解信息的数据），包括其类型 (文件/目录/设备)、长度、文件内容在磁盘上的位置以及指向文件的链接数。
`fstat` 系统调用从文件描述符所引用的 inode 中检索信息。它填充一个 `stat` 类型的结构体，`struct stat` 在**stat. H (kernel/stat. H)**中定义为

```c
#define T_DIR 1    // Directory
#define T_FILE 2   // File
#define T_DEVICE 3 // Device
struct stat {
    int dev;     // 文件系统的磁盘设备
    uint ino;    // Inode编号
    short type;  // 文件类型
    short nlink; // 指向文件的链接数
    uint64 size; // 文件字节数
};
```
## 真实世界
"资源是文件"的概念，Unix 通过一组文件名和文件描述符接口统一访问多种类型的资源 (文件、目录和设备)。