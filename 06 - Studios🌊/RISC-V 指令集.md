---
creation date: 2023-10-18 17:46 
---
 [[2023-10-18-星期三]]  #🌱发芽 #OS #RISC 

RISC-V（“RISC five”）的目标是成为一个通用的指令集架构（ISA），在从最小的到最快的所有计算设备上都能有效工作。

> 用形式逻辑的方法可以很容易看出，存在某种[指令集]在理论上足以控制和执行任意顺序的操作…… 从当前的观点出发，选择一个[指令集]时考虑得更多更实际的问题是：[指令集]要求的设备简单性，在实际重要的问题中有明确应用和解决该类问题的速度。 
> ——冯·诺伊曼（von Neumann）等，1947

## RV32I：RISC-V 基础整数指令集
![image.png](https://jgox-image-1316409677.cos.ap-guangzhou.myqcloud.com/blog/20231018195331.png)

所有的指令都是 32 位长，对于不同的指令采用不同的指令格式。

- 用于寄存器-寄存器操作的 R 类型指令
- 用于短立即数和访存 load 操作的 I 型指令
- 用于访存 store 操作的 S 型指令
- 用于条件跳转操作的 B 类型指令
- 用于长立即数的 U 型指令和用于无条件跳转的 J 型指令

### 寄存器

RV32I 有 31 寄存器加上一个值恒为 0 的 x0 寄存器，全部 32 位宽。

所有操作都在寄存器之间。

### RV32I 整数计算

简单的算术指令（add, sub）、逻辑指令（and, or, xor），以及图 2.1 中的移位指令 （sll, srl, sra）和其他 ISA 差不多。他们从寄存器读取两个 32 位的值，并将 32 位结果写 入目标寄存器。RV32I 还**提供了这些指令的立即数版本**。和 ARM-32 不同，立即数总是进 行符号扩展，这样子如果需要，我们可以用立即数表示负数，正因为如此，我们并不需要 一个立即数版本的 sub。

程序可以根据比较结果生成布尔值。为应对这种使用场景下，RV32I 提供一个当小于 时置位的指令。如果第一个操作数小于第二个操作数，它将目标寄存器设置为 1，否则为 0。不出所料，对这个指令，有一个有符号版本（slt）和无符号版本（sltu），分别用于处 理有符号和无符号整数比较。相应的，上述两条指令也有立即数版本的（slti，sltiu）。


## RISC-V 汇编语言

## RV32M：乘法和除法指令

> 只有当没有任何东西可以去除，而不是没有东西可以添加时，我们才最终达到了完美。 
> ——Antoine de Saint Exup’ery, L’Avion, 1940

## RV32F 和 RV32D：单精度和双精度浮点数

RV32F 和 RV32D 使用 32 个独立的 f 寄存器而不是 x 寄存器。使用两组寄存器的主要 原因是：处理器在不增加 RISC-V 指令格式中寄存器描述符所占空间的情况下使用两组寄存 器来将寄存器容量和带宽是乘 2，这可以提高处理器性能。


## RV32/64 特权架构

### 为什么需要特权架构？

- 有效地管理共享资源，常见的共享资源比如内存、输入/输出设备以及内核。
- 保护共享资源，对于内存和 IO 设备采取虚拟内存映射的形式进行抽象，对于内核则采取访问权限整合到映射中。
- 隔离实现细节，以确保系统能够有效地捕获未实现的操作以进行软件模拟，并处理外部异步事件，例如输入/输出事件、定时器事件以及来自其他线程的软中断。为了支持虚拟机监控程序，我们还需要进行两级地址转换。
主要还是为了实现操作系统的防御性，防御应用程序破坏操作系统的隔离性。
[[MIT 6.S081 Lec03 操作系统组织结构#用户态 / 内核态]] 

### 机器模式 M-mode

机器模式（缩写为 M 模式，M-mode）是 RISC-V 中 hart（hardware thread，硬件线 程）可以执行的最高权限模式。在 M 模式下运行的 hart 对内存，I/O 和一些对于启动和配 置系统来说必要的底层功能有着完全的使用权。因此它是唯一所有标准 RISC-V 处理器都 必须实现的权限模式。实际上简单的 RISC-V 微控制器仅支持 M 模式。

- 拦截
- 异常处理（不寻常的运行时事件）
	- 同步异常，这类异常在指令执行期间产生，如访问了无效的存储器地址或执行了具有无效操作码的指令时。
	- 中断，它是与指令流异步的外部事件，比如鼠标的单击。
		- 软件
		- 时钟
		- 外部来源

### 用户模式 U-mode

虽然机器模式对于简单的嵌入式系统已经足够，但它仅适用于那些整个代码库都可信 的情况，因为 M 模式可以自由地访问硬件平台。更常见的情况是，不能信任所有的应用程 序代码，因为不能事先得知这一点，或者它太大，难以证明正确性。因此，RISC-V 提供了 保护系统免受不可信的代码危害的机制，并且为不受信任的进程提供隔离保护。

必须禁止不可信的代码执行特权指令（如 mret）和访问特权控制状态寄存器（如 mstatus），因为这将允许程序控制系统。这样的限制很容易实现，只要加入一种额外的权 限模式：用户模式（U 模式）。这种模式拒绝使用这些功能，并在尝试执行 M 模式指令或 访问 CSR 的时候产生非法指令异常。

### 现代操作系统的监管者模式 S-mode

提供内存隔离的解决方案：使用基于页面的虚拟内存。这个功能构成了监管者模式（S 模式）的核心，这是一种可选的权限模 式，旨在支持现代类 Unix 操作系统，如 Linux，FreeBSD 和 Windows。S 模式比 U 模式权 限更高，但比 M 模式低。与 U 模式一样，S 模式下运行的软件不能使用 M 模式的 CSR 和 指令，并且受到 PMP 的限制。

### 基于页面的虚拟内存

一个叫 satp（Supervisor Address Translation and Protection，监管者地址转换和保护） 的 S 模式控制状态寄存器控制了分页系统。satp 有三个域。MODE 域可以开启分页并选择页表级数，图 10.13 展示了它的编码。ASID（Address Space Identifier， 地址空间标识符）域是可选的，它可以用来降低上下文切换的开销。最后，**PPN 字段保存 了根页表的物理地址，它以 4 KiB 的页面大小为单位**。

![image.png](https://jgox-image-1316409677.cos.ap-guangzhou.myqcloud.com/blog/20231018203356.png)

当在 satp 寄存器中启用了分页时，S 模式和 U 模式中的虚拟地址会以从根部遍历页表 的方式转换为物理地址。图 10.14 描述了这个过程： 

1. satp. PPN 给出了一级页表的基址，VA[31:22]给出了一级页号，因此处理器会读取位于地址 (satp. PPN × 4096 + VA[31: 22] × 4)的页表项。 
2. 该 PTE 包含二级页表的基址，VA[21:12]给出了二级页号，因此处理器读取位于地址 (PTE. PPN × 4096 + VA[21: 12] × 4)的叶节点页表项。 
3. 叶节点页表项的 PPN 字段和页内偏移（原始虚址的最低 12 个有效位）组成了最 终结果：物理地址就是(LeafPTE. PPN × 4096 + VA[11: 0])


