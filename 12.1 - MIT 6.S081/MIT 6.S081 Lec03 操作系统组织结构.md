---
creation date: 2023-09-25 20:43 
---
 [[2023-09-25-星期一]]  #🌱发芽
# 操作系统组织结构

![](https://jgox-image-1316409677.cos.ap-guangzhou.myqcloud.com/blog/image%20(61).png)

- Isolation。隔离性是设计操作系统组织结构的驱动力。
- Kernel和User mode。这两种模式用来隔离操作系统内核和用户应用程序。
- System calls。系统调用是你的应用程序能够转换到内核执行的基本方法，这样你的用户态应用程序才能使用内核服务。


## 隔离性
我们期望的是，每个用户程序都被装进一个盒子里，这样它们就不会彼此影响了。类似的，我们也想让它们与内核操作系统相互独立，这样如果某个应用程序无意或者故意做了一些坏事，也不会影响到操作系统。这是我们对于隔离性的期望。
- 我们在用户空间有多个应用程序，例如 Shell，echo，find。但是，如果你通过 Shell 运行你们的 Prime 代码（lab1中的一个部分）时，假设你们的代码出现了问题，Shell 不应该会影响到其他的应用程序。举个反例，如果 Shell 出现问题时，杀掉了其他的进程，这将会非常糟糕。所以你需要<span style="background:#fff88f">在不同的应用程序之间有强隔离性。</span>
- 操作系统某种程度上为所有的应用程序服务。当你的应用程序出现问题时，你会希望操作系统不会因此而崩溃。比如说你向操作系统传递了一些奇怪的参数，你会希望操作系统仍然能够很好的处理它们（能较好的处理异常情况）。所以，你也需要<span style="background:#fff88f">在应用程序和操作系统之间有强隔离性。</span>

如果没有操作系统？我们可以将系统调用实现为一些库文件，应用程序可以与之链接。在此方案中，每个应用程序甚至可以根据自己的需求定制自己的库。应用程序可以直接与硬件资源交互，并以应用程序的最佳方式使用这些资源。  


然而，应用程序合作之间互不信任且存在 bug，可能会出现某个程序**霸占 CPU** 并且极易发生**内存泄露**问题，所以人们通常希望提供比合作方案更强的隔离。默认情况下是没有内存隔离性的，内存泄露问题很容易发生。所以，我们想要某种机制，能够将不同程序之间的内存隔离开来，这样类似的事情就不会发生。

> 如果我们从隔离的角度来稍微看看Unix接口，那么我们可以发现，接口被精心设计以实现资源的强隔离，也就是multiplexing和物理内存的隔离。接口通过抽象硬件资源，从而使得提供强隔离性成为可能。 


## 抽象系统资源为服务

为了**实现强隔离**，最好禁止应用程序直接访问敏感的硬件资源，而是**将资源抽象为服务**。
- <span style="background:#fff88f">将磁盘资源抽象为文件系统</span>，应用程序不会直接读写挂在计算机上的磁盘本身，并且在Unix中这也是不被允许的。Unix 应用程序只通过文件系统的 `open`、`read`、`write` 和 `close` 系统调用与存储交互，而不是直接读写磁盘。这为应用程序提供了方便实用的路径名，并允许操作系统（作为接口的实现者）管理磁盘。
- <span style="background:#fff88f">将 CPU 抽象为进程</span>。进程本身不是 CPU，但是它们对应了 CPU，它们使得你可以在 CPU 上运行计算任务。所以你懂的，应用程序不能直接与 CPU 交互，只能与进程交互。  **操作系统不是直接将 CPU 提供给应用程序，而是向应用程序提供“进程”，进程抽象了 CPU，这样操作系统才能在多个应用程序之间复用一个或者多个 CPU。**
  > Unix 在进程之间透明地切换硬件处理器，根据需要保存和恢复寄存器状态，这样应用程序就不必意识到分时共享的存在。这种透明性允许操作系统共享处理器，即使有些应用程序处于无限循环中。

- <span style="background:#fff88f">将内存抽象为 exec</span>，Unix 进程使用 `exec` 来构建它们的内存映像，而不是直接与物理内存交互。这允许操作系统决定将一个进程放在内存中的哪里；如果内存很紧张，操作系统甚至可以将一个进程的一些数据存储在磁盘上。`exec` 还为用户提供了存储可执行程序映像的文件系统的便利。

## 防御性

- 操作系统需要确保所有的组件都能工作，所以它需要做好准备抵御来自应用程序的攻击。
- 应用程序不能够打破对它的隔离。<font color="#ff0000">应用程序非常有可能是恶意的</font>，它或许是由攻击者写出来的，攻击者或许想要打破对应用程序的隔离，进而控制内核。一旦有了对于内核的控制能力，你可以做任何事情，因为内核控制了所有的硬件资源。

如果操作系统需要具备防御性，那么在应用程序和操作系统之间需要有一堵**厚墙**，并且操作系统可以在这堵墙上执行任何它想执行的策略。通常来说，需要通过**硬件来实现强隔离性**。
- 用户态/内核态 user/kernel mode
- page table 或者虚拟内存 Virtual Memory

### 用户态 / 内核态
> [!NOTE]
> 用户态=用户模式=目态
>
> 核心态=管理模式=管态


<span style="background:#fff88f">CPU 为强隔离提供硬件支持。</span>为了支持user/kernel mode，处理器会有<span style="background:#fff88f">两种操作模式</span>，第一种是user mode，第二种是kernel mode。当运行在kernel mode时，CPU可以运行<font color="#ff0000">特定权限</font>的指令（privileged instructions）；当运行在user mode时，CPU只能运行<font color="#ff0000">普通权限</font>的指令（unprivileged instructions）。
- 普通权限的指令都是一些你们熟悉的指令，例如将两个寄存器相加的指令ADD、将两个寄存器相减的指令SUB、跳转指令JRC、BRANCH指令等等。这些都是普通权限指令，所有的应用程序都允许执行这些指令。
- 特殊权限指令主要是一些直接操纵硬件的指令和设置保护的指令，例如设置page table寄存器、关闭时钟中断。在处理器上有各种各样的状态，操作系统会使用这些状态，但是只能通过特殊权限指令来变更这些状态。
> 举个例子，当一个应用程序尝试执行一条特殊权限指令，因为不允许在 user mode 执行特殊权限指令，处理器会拒绝执行这条指令。通常来说，这时会将控制权限从 user mode 切换到 kernel mode，当操作系统拿到控制权之后，或许会杀掉进程，因为应用程序执行了不该执行的指令。

### 虚拟内存

Xv6使用页表（由硬件实现）为每个进程提供自己的地址空间。RISC-V页表**将虚拟地址（RISC-V指令操纵的地址）转换（或“映射”）为物理地址（CPU芯片发送到主存储器的地址）。**

![](https://jgox-image-1316409677.cos.ap-guangzhou.myqcloud.com/blog/image%20(17).png)

**每一个进程都会有自己独立的 page table**，定义了该进程的地址空间。这样的话，每一个进程只能访问出现在自己 page table 中的物理内存。操作系统会设置 page table，使得每一个进程都有不重合的物理内存，这样一个进程就不能访问其他进程的物理内存，因为其他进程的物理内存都不在它的 page table 中。
*一个进程甚至都不能随意编造一个内存地址，然后通过这个内存地址来访问其他进程的物理内存。* 这样就给了我们内存的强隔离性。
page table定义了对于内存的视图，而每一个用户进程都有自己对于内存的独立视图。这给了我们非常强的内存隔离性。

### 用户态和内核态的切换

当 ls 程序运行的时候，会调用 read/write 系统调用；Shell 程序会调用 fork 或者 exec 系统调用，所以必须要有一种方式可以使得用户的应用程序能够将控制权以一种协同工作的方式转移到内核，这样内核才能提供相应的服务。即**需要有一种方式能够让应用程序可以将控制权转移给内核（Entering Kernel）**。

在 RISC-V 中，ECALL 指令用来实现这个功能。
ECALL接收一个数字参数，当一个用户程序想要将程序执行的控制权转移到内核，它只需要执行ECALL指令，并传入一个数字。数字参数代表了应用程序想要调用的System Call。ECALL会跳转到内核中一个特定，由内核控制的位置。

> 举个例子，不论是 Shell 还是其他的应用程序，当它在用户空间执行 fork 时，它并不是直接调用操作系统中对应的函数，而是调用 ECALL 指令，并将 fork 对应的数字作为参数传给 ECALL。之后再通过 ECALL 跳转到内核。
> 
> **在内核侧，有一个位于 syscall. c 的函数 syscall，每一个从应用程序发起的系统调用都会调用到这个 syscall 函数**，syscall 函数会检查 ECALL 的参数，通过这个参数内核可以知道需要调用的是 fork（3.9会有相应的代码跟踪介绍）。
> 
> 假设我现在要执行另一个系统调用 write，相应的流程是类似的，write 系统调用不能直接调用内核中的 write 代码，而是由封装好的系统调用函数执行 ECALL 指令。所以 write 函数实际上调用的是 ECALL 指令，指令的参数是代表了 write 系统调用的数字。之后控制权到了 syscall 函数，syscall 会实际调用 write 系统调用。

用户空间和内核空间的界限是一个硬性的界限，用户不能直接调用 fork，用户的应用程序执行系统调用的唯一方法就是通过这里的 ECALL 指令！

### 内核组织——宏内核 / 微内核

现在，我们有了一种方法，可以通过系统调用或者说ECALL指令，将控制权从应用程序转到操作系统中。之后内核负责实现具体的功能并检查参数以确保不会被一些坏的参数所欺骗。所以内核有时候也被称为**可被信任的计算空间（Trusted Computing Base）**，在一些安全的术语中也被称为TCB。

一个有趣的问题是，什么程序应该运行在kernel mode？敏感的代码肯定是运行在kernel mode，因为这是Trusted Computing Base。
- <span style="background:#fff88f">整个操作系统代码都运行在 kernel mode。</span>大多数的 Unix 操作系统实现都运行在 kernel mode。比如，XV6中，所有的操作系统服务都在 kernel mode 中，这种形式被称为 Monolithic Kernel Design（[宏内核](https://en.wikipedia.org/wiki/Monolithic_kernel)）。
	- 从安全的角度来说，在内核中有大量的代码是宏内核的缺点，容易出现致命错误导致内核崩溃。
	- 子模块现在都位于同一个程序中，它们可以紧密的集成在一起，这样的集成提供很好的性能。
- <span style="background:#fff88f">减少内核中的代码</span>，它被称为 Micro Kernel Design（[微内核](https://en.wikipedia.org/wiki/Microkernel)）。在这种模式下，希望在 kernel mode 中运行尽可能少的代码。所以这种设计下还是有内核，但是内核只有非常少的几个模块，例如，内核通常会有一些 IPC 的实现或者是 Message passing；非常少的虚拟内存的支持，可能只支持了 page table；以及分时复用 CPU 的一些支持。
	- 在内核中的代码的数量较小，更少的代码意味着更少的 Bug。
	- 在 user/kernel mode 反复跳转带来的性能损耗。
	- 在一个类似宏内核的紧耦合系统，各个组成部分，例如文件系统和虚拟内存系统，可以很容易的共享page cache。而在微内核中，每个部分之间都很好的隔离开了，这种共享更难实现。进而导致更难在微内核中得到更高的性能。


## 编译运行kernel

1. 首先，Makefile（XV6目录下的文件）会读取一个 C 文件，例如 proc. c；
2. 之后调用 gcc 编译器，生成一个文件叫做 proc. s，这是 RISC-V 汇编语言文件；
3. 之后再走到汇编解释器，生成 proc. o，这是汇编语言的二进制格式。
   Makefile 会为所有内核文件做相同的操作，比如说 pipe. c，会按照同样的套路，先经过 gcc 编译成 pipe. s，再通过汇编解释器生成 pipe. o。
4. 之后，系统加载器（Loader）会收集所有的. o 文件，将它们链接在一起，并生成内核文件。


