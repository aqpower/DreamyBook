---
creation date: 2023-09-11 20:57 
---
 [[2023-09-11-星期一]]  #🌱发芽

[[MIT6.S081 - Lab1]]

启动 xv6 环境。
```shell
git clone https://github.com/mit-pdos/xv6-riscv.git

cd xv6-riscv

make clean

make qemu
```

## Frok 系统调用创建子进程
子进程从父进程拷贝了所有的内存
> 在编译之后，你的 C 程序就是一些在内存中的指令，这些指令存在于内存中。所以这些指令可以被拷贝，因为它们就是内存中的字节，它们可以被拷贝到别处。通过一些有关虚拟内存的技巧，可以使得子进程的内存与父进程的内存一样，这里实际就是将父进程的内存镜像拷贝给子进程，并在子进程中执行。
> 实际上，当我们在看 C 程序时，你应该认为它们就是一些机器指令，这些机器指令就是内存中的数据，所以可以被拷贝。
> 
> 子进程从父进程中拷贝了所有的内存，是指在 Unix/Linux 操作系统中，创建一个子进程时，子进程会复制父进程的内存空间，以便子进程可以独立地运行而不会干扰父进程或其他进程。这是为了实现进程的独立性和隔离性而采用的一种常见策略。

这种复制内存的过程通常是通过操作系统的虚拟内存机制来实现的，具体如下：

1. **父进程的内存空间：** 当父进程创建子进程时，父进程的整个内存空间，包括代码、数据、堆、栈等内容都会被复制到子进程中。这样，子进程就拥有了与父进程相同的内存副本。
    
2. **写时复制（Copy-On-Write，COW）：** 实际的内存复制通常是延迟的，也就是说，操作系统不会立即复制父进程的内存，而是使用写时复制策略。这意味着只有在子进程或父进程尝试修改某个内存页的内容时，才会进行实际的复制操作。在大多数情况下，子进程只是共享与父进程相同的内存页，这可以节省内存和提高性能。
    

为什么要这样做？

1. **独立性和隔离性：** 通过拷贝父进程的内存，子进程可以独立运行，不会受到父进程的影响，也不会影响父进程。这实现了进程之间的隔离，使它们不会相互干扰。
    
2. **效率：** 使用写时复制策略可以在创建子进程时显著节省内存和时间，因为不需要立即复制所有的内存。只有在必要时才进行复制操作，这可以提高效率。
    
3. **快速创建进程：** 子进程的创建变得非常迅速，因为它只需要建立一个指向父进程内存的链接，而不是复制所有的内存。
    

总之，子进程从父进程拷贝内存的目的是为了实现独立性和隔离性，同时保持效率。这是操作系统中的一项关键技术，用于支持多进程并行执行，每个进程都有自己独立的内存空间。
## exec 系统调用--取代当前进程
int exec (char *file, char *argv[]) 加载一个文件并使用参数执行它; 只有在出错时才返回
exec 系统调用会从指定的文件中读取并加载指令，并替代当前调用进程的指令。从某种程度上来说，这样相当于丢弃了调用进程的内存，并开始执行新加载的指令。
```c
char *argv[] = { "echo", "this", "is", "echo", 0};

exec("echo", argv);
```

> 学生提问：argv 中的最后一个0是什么意思？
> Robert 教授：它标记了数组的结尾。C 是一个非常低阶（接近机器语言）的编程语言，并没有一个方法来确定一个数组究竟有多长。所以为了告诉内核数组的结尾在哪，我们将0作为最后一个指针。**argv 中的每一个字符串实际上是一块包含了数据的内存指针，但是第5个元素是0，通常来说指针0是一个 NULL 指针，它只表明结束**。所以内核中的代码会遍历这里的数组，直到它找到了值为0的指针。

操作系统从名为 echo 的文件中加载指令到当前的进程中，并**替换**了当前进程的内存，之后开始执行这些新加载的指令。同时，你可以传入命令行参数，exec 允许你传入一个命令行参数的数组，这里就是一个 C 语言中的指针数组，在上面代码的第10行设置好了一个字符指针的数组，这里的字符指针本质就是一个字符串（string）。
所以这里等价于运行echo命令，并带上“this is echo” 这三个参数。
- 1.exec 系统调用<span style="background:#fff88f">会保留当前的文件描述符表单</span>。所以任何在 exec 系统调用之前的文件描述符，例如0，1，2等。它们在新的程序中表示相同的东西。

- 2.通常来说exec系统调用不会返回，因为exec会完全替换当前进程的内存，相当于当前进程不复存在了，所以exec系统调用已经没有地方能返回了。exec系统调用只会在出错的时候返回给调用进程。

这就是一个程序如何用文件中的另一个程序来替代自己。实际上，当我们在Shell中运行类似于“echo a b c”的指令，或者ls，或者任何命令，我们不会想要代替Shell进程，所以我们不会希望Shell执行exec系统调用。如果我们这么做了，这里会用echo指令来替代Shell进程，当echo退出了，一切就结束了。所以我们不想要echo替代Shell。实际上，Shell会执行fork，之后fork出的子进程再调用exec系统调用，这是一个非常常见的Unix程序调用风格。对于那些想要运行程序，但是还希望能拿回控制权的场景，可以先执行fork系统调用，然后在子进程中调用exec。

## 文件描述符
文件描述符是一个小整数(small integer)，表示**进程可以读取或写入的由内核管理的对象**。进程*可以通过打开一个文件、目录、设备，或创建一个管道，或复制一个已存在的描述符来获得*一个文件描述符。为了简单起见，我们通常将文件描述符所指的对象称为“文件”；文件描述符接口将文件、管道和设备之间的差异抽象出来，使它们看起来都像字节流。我们将输入和输出称为 I/O。


## fork 和 exec 分离
在这两个调用之间，shell有机会对子进程进行I/O重定向，而不会干扰主shell的I/O设置。

## close (0)
关闭当前进程的标准输入

## 管道


任何操作系统都必须在底层硬件上复用进程，彼此隔离进程，并提供受控制的进程间通讯机制。