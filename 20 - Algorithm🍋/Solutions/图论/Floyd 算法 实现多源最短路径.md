#算法 #图论 #最短路径 
我总是忘记的 **Floyd 算法** 
是用来求任意两个结点之间的最短路的。
复杂度比较高，但是常数小，容易实现。（我会说只有三个 `for` 吗？）
适用于任何图，不管有向无向，边权正负，但是最短路必须存在。（不能有个负环）
## 实现
### 理解一
Floyd 算法的基本思想是，设 d[i][j]表示从节点 i 到节点 j 的最短路径长度，初始时 d[i][j]为 i 到 j 的边的权值，如果不存在 i 到 j 的边，则 d[i][j]为一个极大值。然后通过对 d 数组的递推更新，不断更新 i 到 j 的最短路径长度，直到所有的 d[i][j]都求出来。

具体来说，Floyd 算法通过三重循环来递推计算 d 数组。外层循环枚举中间节点 k，内层循环枚举起点 i 和终点 j，如果从 i 到 k 到 j 的路径比 i 到 j 的路径更短，则更新 d[i][j]的值。最后得到的 d 数组即为每一对节点之间的最短路径长度。

### 理解二
Floyd 算法的核心思想是动态规划。对于图中的任意两个节点 i 和 j，假设它们之间的最短路径经过节点 k，则这条路径可以拆成两个部分：从 i 到 k 的路径和从 k 到 j 的路径。因此，可以得到以下状态转移方程：
```C++
d[i][j] = min(d[i][j], d[i][k] + d[k][j])
```
这个方程的含义是，如果从i到j经过k的路径比当前已知的最短路径更短，则更新d[i][j]的值。

```c++
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            d[i][j] = i == j ? 0 : 1e9;
        }
    }
    int u, v, w;
    for (int k = 0; k < m; k++) {
        cin >> u >> v >> w;
        d[u][v] = min(w, d[u][v]);
    }
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
            }
        }
    }
```